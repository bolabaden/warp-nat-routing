


volumes:
  warp-config-data:


configs:
  warp-nat-setup.sh:
    file: ./warp-nat-setup.sh


networks:
  stack-net:
    driver: bridge
  warp-nat-net:
    external: true  # docker network create --attachable -o com.docker.network.bridge.name=br_warp-nat-net -o com.docker.network.bridge.enable_ip_masquerade=false warp-nat-net
    attachable: true
  publicnet:
    driver: bridge


services:
  warp-nat-gateway:
    # ðŸ”¹ðŸ”¹ WARP in Docker (with NAT)ðŸ”¹
    image: docker.io/caomingjun/warp:latest
    container_name: warp-nat-gateway
    hostname: warp-nat-gateway
    extra_hosts:
      - host.docker.internal:host-gateway
    expose:
      - ${GOST_SOCKS5_PORT:-1080}  # SOCKS5 proxy port
    # add removed rule back (https://github.com/opencontainers/runc/pull/3468)
    device_cgroup_rules:
      - 'c 10:200 rwm'
    cap_add:
      # Docker already have them, these are for podman users
      - MKNOD
      - AUDIT_WRITE
      # additional required cap for warp, both for podman and docker
      - NET_ADMIN
    sysctls:
      - net.ipv6.conf.all.disable_ipv6=0
      - net.ipv4.conf.all.src_valid_mark=1
      - net.ipv4.ip_forward=1
      - net.ipv6.conf.all.forwarding=1
      - net.ipv6.conf.all.accept_ra=2
    volumes:
      - warp-config-data:/var/lib/cloudflare-warp
    environment:
      # If set, will add checks for host connectivity into healthchecks and automatically fix it if necessary.
      # See https://github.com/cmj2002/warp-docker/blob/main/docs/host-connectivity.md for more information.
      BETA_FIX_HOST_CONNECTIVITY: false
      # The arguments passed to GOST. The default is -L :1080, which means to listen on port 1080 in the container at the same time through HTTP and SOCKS5 protocols.
      # If you want to have UDP support or use advanced features provided by other protocols, you can modify this parameter. For more information, refer to https://v2.gost.run/en/.
      # If you modify the port number, ensure you modify the `ports:` section above.
      GOST_ARGS: ${GOST_ARGS:--L :${GOST_SOCKS5_PORT:-1080}}
      # If set, will register consumer account (WARP or WARP+, in contrast to Zero Trust) even when mdm.xml exists.
      # You usually don't need this, as mdm.xml are usually used for Zero Trust.
      # However, some users may want to adjust advanced settings in mdm.xml while still using consumer account.
      #REGISTER_WHEN_MDM_EXISTS: ""
      # If set, will work as warp mode and turn NAT on.
      # You can route L3 traffic through warp-docker to Warp.
      # See https://github.com/cmj2002/warp-docker/blob/main/docs/nat-gateway.md for more information.
      WARP_ENABLE_NAT: true
      # The license key of the WARP client, which is optional.
      # If you have subscribed to WARP+ service, you can fill in the key in this environment variable.
      # If you have not subscribed to WARP+ service, you can ignore this environment variable.
      WARP_LICENSE_KEY: ${WARP_LICENSE_KEY}
      # The time to wait for the WARP daemon to start, in seconds.
      # If the time is too short, it may cause the WARP daemon to not start before using the proxy, resulting in the proxy not working properly.
      # If the time is too long, it may cause the container to take too long to start. If your server has poor performance, you can increase this value appropriately.
      WARP_SLEEP: 2  # The default is 2 seconds.
    healthcheck: &warp-healthcheck
      test: [
        "CMD-SHELL",
        "sh -c \"if curl -s https://cloudflare.com/cdn-cgi/trace | grep -qE '^warp=on|warp=plus$'; then echo \\\"Cloudflare WARP is active.\\\" && exit 0; else echo \\\"Cloudflare WARP is not active.\\\" && exit 1; fi\""
      ]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 10s
    restart: always
  warp_router:
    depends_on:
      warp-nat-gateway:
        condition: service_healthy
    build:
      dockerfile_inline: |
        FROM alpine:latest
        RUN apk update && apk add \
            bash bc docker-cli ipcalc iproute2 iptables jq util-linux && \
            rm -rf /var/cache/apk/*
        CMD ["/bin/bash", "/usr/local/bin/warp-nat-setup.sh"]
    container_name: warp_router
    privileged: true
# unsure if any of these are required or not
#    cap_add:
#      - NET_ADMIN
#      - NET_RAW
#      - SYS_ADMIN
    network_mode: host
    configs:
      - source: warp-nat-setup.sh
        target: /usr/local/bin/warp-nat-setup.sh
        mode: 700
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:rw
      - /etc/iproute2/rt_tables:/etc/iproute2/rt_tables:rw
      - /proc:/proc:rw
    environment:
      DOCKER_HOST: ${DOCKER_HOST:-unix:///var/run/docker.sock}
      DOCKER_NETWORK_NAME: ${DOCKER_NETWORK_NAME:-warp-nat-net}
      WARP_CONTAINER_NAME: ${WARP_CONTAINER_NAME:-warp-nat-gateway}
      HOST_VETH_IP: ${HOST_VETH_IP:-169.254.100.1}
      CONT_VETH_IP: ${CONT_VETH_IP:-169.254.100.2}
      ROUTING_TABLE: ${ROUTING_TABLE:-warp-nat-routing}
      VETH_HOST: ${VETH_HOST:-veth-warp}  # 9 character maximum
    restart: no

  ip-checker-naked:
    # ðŸ”¹ðŸ”¹ IP Checker Naked ðŸ”¹ðŸ”¹
    # This is a service that checks the IP address of the container.
    # It uses the default network interface of the host.
    build: &ip-checker-dockerfile
      context: .
      dockerfile_inline: |
        FROM alpine:latest
        RUN apk add --no-cache curl ipcalc
    container_name: ip-checker-naked
    command: "/bin/sh -c 'while true; do echo \"$$(date): $$(curl -s --max-time 4 ifconfig.me)\"; sleep 5; done'"
    healthcheck:
      test: [
        "CMD-SHELL",
        "sh -c \"if curl -s https://cloudflare.com/cdn-cgi/trace | grep -qE '^warp=on|warp=plus$'; then  exit 1; else exit 0; fi\""
      ]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 10s
  ip-checker-warp:
    # ðŸ”¹ðŸ”¹ IP Checker WARP ðŸ”¹ðŸ”¹
    # This is a service that checks the IP address of the container.
    # It uses the WARP network interface.
    build: *ip-checker-dockerfile
    container_name: ip-checker-warp
    networks:
      - warp-nat-net
    command: "/bin/sh -c 'while true; do echo \"$$(date): $$(curl -s --max-time 4 ifconfig.me)\"; sleep 5; done'"
    healthcheck: *warp-healthcheck
    restart: always
  ip-checker-warp-multi-ambiguous:
    # ðŸ”¹ðŸ”¹ IP Checker WARP Multi Uses Public ðŸ”¹ðŸ”¹
    # This is a service that checks the IP address of the container.
    # As shown, without `gw_priority` set the network chosen for the default route of this container uses some funky non-intuitive logic:
    # - Docker's default route uses the subnet of the last connected network, per old info.
    # - In Docker Compose, setting gw_priority to a high number, like 100, makes a network the default gateway.
    # - Default gateway depends on the order networks are connected, with the last one often becoming default.
    build: *ip-checker-dockerfile
    container_name: ip-checker-warp-multi-ambiguous
    networks:
      - warp-nat-net
      - publicnet
    command: "/bin/sh -c 'while true; do echo \"$$(date): $$(curl -s --max-time 4 ifconfig.me)\"; sleep 5; done'"
    restart: always
  ip-checker-warp-multi-uses-warp:
    # ðŸ”¹ðŸ”¹ IP Checker WARP Multi Uses WARP ðŸ”¹ðŸ”¹
    # This is a service that checks the IP address of the container.
    # `warp_network` gateway priority 1, higher than public, so warp will be used by default.
    build: *ip-checker-dockerfile
    container_name: ip-checker-warp-multi-uses-warp
    networks:
      warp-nat-net:
        # Default gateway is set by the last connected network or by gw_priority (e.g., 100), with Docker using the last network by default unless gw_priority is specified.
        gw_priority: 1  # https://docs.docker.com/engine/network/#connecting-to-multiple-networks
      publicnet: {}
    command: "/bin/sh -c 'while true; do echo \"$$(date): $$(curl -s --max-time 4 ifconfig.me)\"; sleep 5; done'"
    healthcheck: *warp-healthcheck
  stack-network-checker:
    image: alpine:latest
    container_name: stack-network-checker
    networks:
      - stack-net
    command: "/bin/sh -c 'while true; do echo \"$$(date): $$(ping -c 1 8.8.8.8)\"; sleep 5; done'"
    healthcheck:
      test: ["CMD-SHELL", "ping -c 1 8.8.8.8"]
      interval: 30s
      timeout: 5s
      retries: 3
    restart: always